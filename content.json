{"meta":{"title":"XJ Studio","subtitle":"It's Xingjian Hao's Personal Blog","description":"","author":"Xingjian Hao","url":"https://xjhao.studio","root":"/"},"pages":[{"title":"Archives","date":"2021-12-05T16:10:01.000Z","updated":"2021-12-06T04:10:00.000Z","comments":true,"path":"archives/index.html","permalink":"https://xjhao.studio/archives/index.html","excerpt":"","text":""},{"title":"category","date":"2020-06-25T17:10:36.000Z","updated":"2022-03-22T20:06:08.000Z","comments":true,"path":"categories/index.html","permalink":"https://xjhao.studio/categories/index.html","excerpt":"","text":""},{"title":"Reading List","date":"2022-09-07T02:10:22.000Z","updated":"2023-03-03T16:53:06.868Z","comments":true,"path":"collections/index.html","permalink":"https://xjhao.studio/collections/index.html","excerpt":"","text":"What’s this Page?This is a place I use to store all useful resources and articles. They are certified by myself to be helpful and worth-reading. AlgorithmsLabuladong Leetcode Highly detailed leetcode explanation and guide note book. All topics covers around 150 algorithm questions. Neetcode Very useful roadmap for beginners to start leetcode. Blind 75 High-frequency leetcode questions by companies. Very useful for interview preparation. Machine Learning&#x2F; Deep LearningSystem Design Consistency Note from Colorado State University A detailed explanation of consistency models. Web Develop Tools ionicons Icons for all kind of social media and objects for representation. Easy to plug-in and offer three different sets of edge types. instruqt Interactive lab for active web applications and has detailed tutorial. As a substitute for katacode, it’s easier to get hand on but don’t have much liberty to messing around and try your own thought. CurriculumLearn CS A collection of CS curriculum from MIT, Stanford, CMU and UC Berkeley."},{"title":"About Me","date":"2021-12-05T16:08:18.000Z","updated":"2023-11-05T07:31:17.697Z","comments":true,"path":"about/index.html","permalink":"https://xjhao.studio/about/index.html","excerpt":"","text":"Hi, this is Xingjian… Who am IGraduate Student at Brown University. Born and raised in Jinan, China. Amateur guitarist, photographer, rock enthusiastic and more. What can I doSome skill stacks I have… Programming Language (C++, Python, Go) Web Development (JavaScript, React, Vue, Node) Distributed System (k8s, ceph, rook, MapReduce) Cloud Service (AWS EC2, AWS S3) ML&#x2F;DL (Tensorflow, Pytorch, SciKit) About this WebsiteThis website is build on Hexo with theme Aomori. Comment system based on giscus, and site-wise seraching based on Algolia. Some of the cover pictures are collected from Pexels, a copyright free photography website."},{"title":"Friends","date":"2020-06-25T17:11:00.000Z","updated":"2023-02-27T04:31:13.189Z","comments":true,"path":"friends/index.html","permalink":"https://xjhao.studio/friends/index.html","excerpt":"","text":""},{"title":"'tag'","date":"2020-06-25T17:10:44.000Z","updated":"2022-09-07T04:31:54.000Z","comments":true,"path":"tag/index.html","permalink":"https://xjhao.studio/tag/index.html","excerpt":"","text":""},{"title":"Search","date":"2023-02-26T02:55:44.884Z","updated":"2022-03-22T16:26:40.000Z","comments":true,"path":"search/index.html","permalink":"https://xjhao.studio/search/index.html","excerpt":"","text":""}],"posts":[{"title":"Make Your Timeline Clean: Git Rebase & Git Squash","slug":"Make-Your-Timeline-Clean-Git-Rebase-Git-Squash","date":"2023-09-04T08:22:46.000Z","updated":"2023-11-05T06:35:12.911Z","comments":true,"path":"09/04/2023/Make-Your-Timeline-Clean-Git-Rebase-Git-Squash/","link":"","permalink":"https://xjhao.studio/09/04/2023/Make-Your-Timeline-Clean-Git-Rebase-Git-Squash/","excerpt":"Version Control is important in software development. A trustworthy version timeline can effectively reduce risks of parallel developing and deploy of new features. Git, as the most popular version control tools adopted by the industry, work together with other derivatives to grant safety of countless products.","text":"Version Control is important in software development. A trustworthy version timeline can effectively reduce risks of parallel developing and deploy of new features. Git, as the most popular version control tools adopted by the industry, work together with other derivatives to grant safety of countless products. When a group grows too large in scale, the timeline of a project could be easily messed-up: multiple feature branches moving forward at same time, frequent merged PRs, rookies trying to merge without a notion of pulling first… On structure, a git repo couple be consideres as a distributed database while every copy of repo is a duplicate that looking for synchoronization. As many distributed systems expecting, the optimal goal for a git repo timeline should be like a linearizatoin: branches split out to gain new features and bring them back before the next split appeared. Although this is impossible to achieve when there are more than three people in the group, we can use two powerful helpers git rebase and git squash to maintain this harmony. FunctionalityBreiefly, git rebase is to move one or multiple commits after a specific point. It can help to resolve the conflicts while your current branch has un-pulled commits by others or prevent a PR that covered newly merged featrues with older version. git squash is a simple command that compress multiple commits into one. More details about those commads can be found here and here on GeeksforGeeks. ApproachTo achieve the look in the above picture, some situations are worthwhile for an apply: Git Rebase: a PR that fall behind serval commits on main branchYou can still making a PR with a outdated part of the repo. When PR is reviewed, only modifications contained in the commits of current branch will be highlighted, since the comparison is made with the split point version of repo. Merging without noticing the missing new features would cause a overwrite of old version to the new ones. Using git rebase in this case is similar with git pull origin main that the result timeline will be acceptable for the main branch. If you are calling the command in terminal, it’s normal to see a coming up error message when you trying to push your update: your local record is diverged from the remote. Since you only rebased your local changes based on local record, the remote side would not be acknowlegded with this update, therefore reject the push. The simplist solution is to complete this rebase with GUI. For example, if your company has adopted the triangle of confluence, jira, bitbucket, you can easily find a rebase option on bitbucket PR. If not, you can still delete the remote branch and push your local as a new branch. Git Squash: multiple unmerged commits that tangling with pulls from main branchThis is very simple to understand: if the commits are unmerged, the timeplie will have a line piece of the working branch that runs parallel with the main line, with multiple connections between. This makes the timeline hard to interpret. By compress multiple commits into one using git squash, the merged timeline will only have a small diverge of the new feature in developing branch, and the logic are simple as a linearization. However, git squash will also create a divergence between local and remote. The simplist solution is always delete the remote branch and push the local as a new one. After a PR is proposed, the branch cannot be deleted anymore util it merged into main, thus this move have to be make before the PR request.","categories":[{"name":"Solutions","slug":"Solutions","permalink":"https://xjhao.studio/categories/Solutions/"}],"tags":[{"name":"Version Control","slug":"Version-Control","permalink":"https://xjhao.studio/tags/Version-Control/"},{"name":"Distributed System","slug":"Distributed-System","permalink":"https://xjhao.studio/tags/Distributed-System/"}]},{"title":"Some Thought on ChatGPT","slug":"chatGPT-UT","date":"2023-02-27T15:15:20.000Z","updated":"2023-11-04T14:56:39.507Z","comments":true,"path":"02/27/2023/chatGPT-UT/","link":"","permalink":"https://xjhao.studio/02/27/2023/chatGPT-UT/","excerpt":"","text":"Thought today: Just realized that chatGPT is so powerful that it can even write unit tests for you – just show it your code and tell it which part you want to be covered. Anxiety level of unemployment boosted. Thank you OpenAI.","categories":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://xjhao.studio/categories/Thoughts/"}],"tags":[]},{"title":"Modist - a Safer Partitioning Option","slug":"modist","date":"2023-02-25T14:36:36.000Z","updated":"2023-02-27T21:47:13.508Z","comments":true,"path":"02/25/2023/modist/","link":"","permalink":"https://xjhao.studio/02/25/2023/modist/","excerpt":"Partitioning is necessary when the size of data exceeds the capacity of a single machine. By distributing the workload on each node, the performance is expected to boost by the coefficient manner. In this project, Modist, I explored the structure and functionalities of a distributed system with sharding&#x2F; partitioning capability, and received some inspiration from the unit test process.","text":"Partitioning is necessary when the size of data exceeds the capacity of a single machine. By distributing the workload on each node, the performance is expected to boost by the coefficient manner. In this project, Modist, I explored the structure and functionalities of a distributed system with sharding&#x2F; partitioning capability, and received some inspiration from the unit test process. Implementation * Due to ethical consideration, this repo will remain private util the end of Spring 2023 semesterModist is a client-server structured system that manage multiple functionalities and interactions between nodes with multiple server process. The client node communicate with routers to get information for future TCP connections and interact with partitioners to locate and replicate the key information. The cluster of all server side nodes is called Orchestrator, which configure each node and build up gRPC connections between them. The connection between nodes are passed through protocol buffers. Protocol buffers are a data format to transfer binary representations of objects across the network, which lead to a higher throughput. Within each buffer, a message is passed to node. Protobuf messages are aggregates containing a set of typed fields: resolveableKV, message key with vector clock tas, required syntactic sugar used by Protobuf to order these fields in the binary format of the message Standard data types (bool, int, etc.) are available as well as keywords like optional and repeated Clock and ConflictsModist take both physical and vector clock as its synchronize tool. Within each node, a resolver is implemented to handle the conflict when to incoming events holds different vector clocks. By definition, the highest clock value on each node will be kept as the latest time marker. The vector clock also handles new event by define empty value as zero, and assign them as concurrent. Modist using these mechanisms to acquire the happen-before relationship between events, and eventually keep a causal consistency. Leaderless ReplicationLeaderless replication is a safety guarantee when one node holding data is done. In Modist, a leaderless replication is applied when a request is made. The process of writing or reading from the replication is called a Quorum. While the client contact the Orchestrator, it use matrices R and W to indicate the number of replication that will participate the operation. Normally, for a given n node system, having W + R &gt; n can guarantee that the replicated key can be read when needed. To reach eventual consistency among nodes, read repair is required. By repair we mean to update the out-dated value on a node to the latest if detected. Therefore, the deterministic will be the vector clock. Coordinator detects stale values on other nodes and locally when it issues a read request, can then correct these values with the most up-to-date value. Unit TestUnit tests are conducted along with the development process of each feature. The goal is to cover the codes as much as possible so all features and operations can be tested without any bug. While composing the testing files, some special cases inspired me and my future unit testing and program designing. Adoptability of nil valueNil value can be tricky when it comes to adoptability. In some cases you just need to treat them as zero, while in other cases its an issue you need to take care of. When it comes to value comparison, recognize them as zero can be a feasible approach. You just need to add some mechanism that assign empty value to zero when read them, and it will be all set for comparison. However, when it becomes to the collecting keys, the nil situation should be treat specially. For example, in Modist, when you trying to read a key from a node that didn’t receive a replication, you can make up a fake clock and return value to indicate the missing value. Fake clock can be acquired by the request clocks, therefore you won’t be worry about mistaken conflicts. Moreover, you need a ignorance mechanism when a nil is detected. Some data structures naturally handles these situations, or you can add additional statement to process only when it return message has a value in it. To be continued…","categories":[{"name":"Programming","slug":"Programming","permalink":"https://xjhao.studio/categories/Programming/"}],"tags":[{"name":"Distributed System","slug":"Distributed-System","permalink":"https://xjhao.studio/tags/Distributed-System/"},{"name":"gRPC","slug":"gRPC","permalink":"https://xjhao.studio/tags/gRPC/"},{"name":"Unit Test","slug":"Unit-Test","permalink":"https://xjhao.studio/tags/Unit-Test/"},{"name":"golang","slug":"golang","permalink":"https://xjhao.studio/tags/golang/"}]},{"title":"Liteminer - Your Crypto Mining Crew","slug":"liteminer","date":"2023-02-07T08:04:00.000Z","updated":"2023-02-28T05:29:30.468Z","comments":true,"path":"02/07/2023/liteminer/","link":"","permalink":"https://xjhao.studio/02/07/2023/liteminer/","excerpt":"Many cryptocurrencies use a distributed consensus protocol to ensure security and authority. In this project I implemented a peer-to-peer networking and proof of work mechanism. In the case of cryptocurrencies, nodes are miners which may drop in and out of the network for various reasons: a miner may crash (or reboot), or a new miner may be added. These changes to the network happen in an unscheduled and unpredictable manner and special care must therefore be taken to ensure that no information is lost.","text":"Many cryptocurrencies use a distributed consensus protocol to ensure security and authority. In this project I implemented a peer-to-peer networking and proof of work mechanism. In the case of cryptocurrencies, nodes are miners which may drop in and out of the network for various reasons: a miner may crash (or reboot), or a new miner may be added. These changes to the network happen in an unscheduled and unpredictable manner and special care must therefore be taken to ensure that no information is lost. Implementation * Due to ethical consideration, this repo will remain private util the end of Spring 2023 semesterMotivated by the hash function within boundaries. By distributing the calculation workload, the eventual proof-of-work is ensured by the key value with largest hash. Since the system required multi-threading and parallel computing, we used Atomic and mutex locks to prevent race condition. Atomic vars are used to protect simple types such as bool, int, string, while mutexes are used to protect maps, slices, and customized structs. Proof of WorkIn cryptocurrencies like Bitcoin, blocks which contain a collection of transactions are constantly created and validated by network participants that perform a computationally intensive task. This is often referred to as proof of work. A common proof of work scheme involves finding a number referred to as a nonce that when concatenated to a string and hashed results in a new string that has a certain property. In Bitcoin, the proof of work entails finding the nonce that, when concatenated with the transaction data and hashed, results in a string that starts with a series of zeros. The fundamental insight is that doing the work to find such a nonce is computationally expensive and requires a lot of resources; therefore, in order to “cheat” the system, one needs to have more resources than all other participants combined. MinerIn a cryptocurrency network, we refer to a miner as a worker that attempts to verify transactions by performing proof of work. Given a financial transaction encoded as a string M and an unsigned integer N, a miner will need to find the nonce between 0 and N, inclusive, that, when concatenated with M and hashed, results in the lowest hash value. PoolA pool is a collection of multiple miners and is responsible for distributing the work amongst its miners. It will also handle top-level logic and communications for a client. A pool and its corresponding miners have the following properties: The pool must take client requests and shard these requests (distribute the work) across all of its miners. The pool must keep track of the miners under its control and allow miners to come and go at will. The pool must aggregate miner responses and return the proof of work to the client. In a centralized system, this process can take a considerable amount of time. In a distributed system, you will be able to divide up the work, but you must take care when dealing with faulty miners (i.e., miners that drop in and out). Our pool takes a channel to marking the waiting mining tasks and to prevent the conflict of concurrent accessing by its FIFO characteristic. When a node is lost, the task will be return to the queue and wait for a new miner to grab. Only when alsl tasks in the channel are taken and all nonces are collect will the pool return a final proof-of-work. The miner will remain alive and waiting for the next mining task from the pool.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://xjhao.studio/categories/Programming/"}],"tags":[{"name":"Distributed System","slug":"Distributed-System","permalink":"https://xjhao.studio/tags/Distributed-System/"},{"name":"golang","slug":"golang","permalink":"https://xjhao.studio/tags/golang/"},{"name":"Cryptocurrency","slug":"Cryptocurrency","permalink":"https://xjhao.studio/tags/Cryptocurrency/"}]},{"title":"AutoMIDI - GAN based Jazz Music Generator","slug":"autoMIDI","date":"2022-12-13T01:12:35.000Z","updated":"2023-02-28T05:29:11.215Z","comments":true,"path":"12/13/2022/autoMIDI/","link":"","permalink":"https://xjhao.studio/12/13/2022/autoMIDI/","excerpt":"Musicians have struggled for years to find an automatic solution for composition. As the development of Artificial Intelligence and Deep Learning, many applications have emerged to provide ideas and insights for songwriters. By aligning the notes and beats correctly, Deep Learning models can dig out the melody that was rarely or never used by prior musicians. In this hackthon project, we proposed to convert audios into image-based files to leverage the idea of CNN, to demonstrates a capability of reconstructing melody-based images after model training with a certain number of epochs.","text":"Musicians have struggled for years to find an automatic solution for composition. As the development of Artificial Intelligence and Deep Learning, many applications have emerged to provide ideas and insights for songwriters. By aligning the notes and beats correctly, Deep Learning models can dig out the melody that was rarely or never used by prior musicians. In this hackthon project, we proposed to convert audios into image-based files to leverage the idea of CNN, to demonstrates a capability of reconstructing melody-based images after model training with a certain number of epochs. GAN, also known as generative adversarial network that estimate generative models via an adversarial process. Other solutions like RNN or CRNN + GAN also exists, and are capable to generate high-quality music piece that has a taste of “Jazz”. Due to the model features, these solutions shows constraints on issues like overfitting, high-variance or computational expensive. After comparison, GAN is decided to be the most stable and desirable for the task of Jazz music composition. MethodologyDatasetsWe collected music datasets from the Kaggle community. This dataset consists of classical piano midi files containing compositions of 19 famous composers. To pursue better performance, the sub-genres of the song selection tend to be only Mozart’ works collection, and they are identified by left and right piano parts. Image Conversion and PreprocessingMelody notes are converted to black and white pixels (0 ~ 255) with a fixed size of 106 X 100 for each image. Row size (106) represents the number of different notes in music. Column size (100) describes the length of the melody. We demonstrate the intuition as the below.. Each image resizes into 106 X 106 pixels for the purpose of convention use in neural network architecture. We also scaled pixel values ranging from -1 to 1 for each image, corresponding to the activate function used in the model. Virtualized process is shown below. Deep Convolutional Generative Adversarial NetworkThe model is mainly composed of two components: Generator and Discriminator. Generator aims to generate new plausible melody-based images from a D-dimensional (D &#x3D; 100) latent space, and Discriminator classifies images as real or fake. GANs are trained in an adversarial manner until the Discriminator fails to identify generated examples as “fake”, in our case, non melody-based images. Discriminator model (left part) is convolutional-based neural network that takes images with the size of 106 X 106 at the input. Generator model (right part) is an up-sampling neural network that takes a 100 dimensions random noise vector as the input to reconstruct the output similar to melody-based images. ResultsDuring the training process, the Generator model came to generate plausible melody-based images along training epochs increases (see Melody training section). At the first thirty epochs, Generator model failed to reconstruct images as both Discriminator and Generator were not well trained yet, which corresponds to low loss as well (see Model evaluation section). These can be interpreted as the following: Discriminator can easily identify “fake” random noises from “real” melody-based images at the beginning given that Generator model has not learned the information that can be used for reconstructing the images. We can observe the model began to generate meaningful notes by extending the duration of training. For performance demonstration, we generated a sample melody-based image by inputting a random nose vector into our well trained Generator model (see Melody generation section). The melody-based image is converted back to midi audio file, together with showing its score for the purpose of evaluation. DiscussionIn this study, we identified music composing as the image generation task by mapping from notes to melody-based images. We successfully generated melody-based images by using Deep Convolutional Generative Adversarial Network. However, this model architecture makes it less durable to train multiple music tracks together. Thus, we combined multi-tracks into one at image level or selected the main melody track (piano), whenever it’s possible, as training data. Future studies should focus on leveraging multiple tracks and fitting into the model simultaneously.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://xjhao.studio/categories/Programming/"}],"tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://xjhao.studio/tags/Deep-Learning/"},{"name":"GAN","slug":"GAN","permalink":"https://xjhao.studio/tags/GAN/"},{"name":"Python","slug":"Python","permalink":"https://xjhao.studio/tags/Python/"}]},{"title":"Fix your npm Installation on macOS","slug":"npmFixMacOS","date":"2022-06-09T16:45:08.000Z","updated":"2023-11-04T09:08:08.101Z","comments":true,"path":"06/10/2022/npmFixMacOS/","link":"","permalink":"https://xjhao.studio/06/10/2022/npmFixMacOS/","excerpt":"If you are new to macOS and just started a npm project, one of the case you might meet is that sometimes your npm can successfully install the package, but whenever you call it the terminal can never find it. For example:","text":"If you are new to macOS and just started a npm project, one of the case you might meet is that sometimes your npm can successfully install the package, but whenever you call it the terminal can never find it. For example: $ npm install &lt;packagename&gt; $ - terminal: installed package $ &lt;packagename&gt; -v $ - terminal: package not found This is very common for the starters, and there are multiple potential causes to be detected. First of all, you need to check if your package is installed globally or locally. $ npm list &#x2F;&#x2F; gives all local installed packages $ npm list -g &#x2F;&#x2F; gives all global installed packages If you do notice that one of your package is not installed globally, you can reinstall it with -g flag. $ npm uninstall &lt;packagename&gt; $ npm install &lt;packagename&gt; -g Afterwards you can try call the package again. But if it still shows like not found, it’s probably your system’s PATH doesn’t get npm binary’s path included. Its also very simple to fix. $ npm root -g &#x2F;&#x2F; gives directory to your global npm binary, copy this $ vim ~&#x2F;.bash_profile &#x2F;&#x2F; open config profile of your system and setup PATH for npm binary $ &#x2F;&#x2F; within the .bash_profile, add the following line $ export PATH&#x3D;$PATH:&#x2F;&lt;your global npm binary directory&gt; $ &#x2F;&#x2F; then save and quit $ source ~&#x2F;.bash_profile &#x2F;&#x2F; reload your profile to activate Then if you call the package, it should be there. There’s also a local alternative that you can add the local path to profile by not adding the -g flag when getting the root. The result will be the same for your current project, but if you start a new project, you’ll need to add or change the PATH in .bash_profile again.","categories":[{"name":"Solutions","slug":"Solutions","permalink":"https://xjhao.studio/categories/Solutions/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"https://xjhao.studio/tags/Tools/"}]},{"title":"Ultimate Solution for Python Environment Setup","slug":"pythonEnvSolution","date":"2021-01-28T06:07:15.000Z","updated":"2023-02-28T19:08:48.240Z","comments":true,"path":"01/28/2021/pythonEnvSolution/","link":"","permalink":"https://xjhao.studio/01/28/2021/pythonEnvSolution/","excerpt":"","text":"Ultimate Solution for Python Environment Setup on your system: install Conda and coding with VS Code","categories":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://xjhao.studio/categories/Thoughts/"}],"tags":[]},{"title":"Correct Method to Deploy your Hexo Website onto Github Pages","slug":"Correct_Method_to_Deploy_your_Hexo_Website_onto_Github_Pages","date":"2020-07-04T16:51:06.000Z","updated":"2023-11-04T09:08:01.386Z","comments":true,"path":"07/05/2020/Correct_Method_to_Deploy_your_Hexo_Website_onto_Github_Pages/","link":"","permalink":"https://xjhao.studio/07/05/2020/Correct_Method_to_Deploy_your_Hexo_Website_onto_Github_Pages/","excerpt":"After weeks of massing around with web platforms, I finally figured out the correct method to deploy my Hexo website onto Github Pages. It’s not hard and not complicated.","text":"After weeks of massing around with web platforms, I finally figured out the correct method to deploy my Hexo website onto Github Pages. It’s not hard and not complicated. Prerequisites: you website, your github repo, a solid internet connection The hexo document website has a detailed instruction about what you should prepare, so I’ll leave the job to them. After your website is finished with all impelmentations you want, run the following command: $ npm install hexo-deployer-git -save This plugin would generate the correct form for your deploy to Github Page. Then open _config.yml of your website and make the following edit: # URL url: https:&#x2F;&#x2F;username.github.io&#x2F; # Deployment deploy: type: git repo: https:&#x2F;&#x2F;github.com&#x2F;&lt;username&gt;&#x2F;&lt;reponame&gt;.git branch: master This would set up the link to your repo, so you don’t have to wake up Git(which makes a lot trouble if you use SSH connection on Windows). Then you are one step before deployment. Simply run: $ hexo clean $ hexo generate $ hexo deploy to generate the correct website and push them into your repo. Then your website should be available on https://username.github.io/.","categories":[{"name":"Solutions","slug":"Solutions","permalink":"https://xjhao.studio/categories/Solutions/"}],"tags":[{"name":"Web Development","slug":"Web-Development","permalink":"https://xjhao.studio/tags/Web-Development/"}]}],"categories":[{"name":"Solutions","slug":"Solutions","permalink":"https://xjhao.studio/categories/Solutions/"},{"name":"Thoughts","slug":"Thoughts","permalink":"https://xjhao.studio/categories/Thoughts/"},{"name":"Programming","slug":"Programming","permalink":"https://xjhao.studio/categories/Programming/"}],"tags":[{"name":"Version Control","slug":"Version-Control","permalink":"https://xjhao.studio/tags/Version-Control/"},{"name":"Distributed System","slug":"Distributed-System","permalink":"https://xjhao.studio/tags/Distributed-System/"},{"name":"gRPC","slug":"gRPC","permalink":"https://xjhao.studio/tags/gRPC/"},{"name":"Unit Test","slug":"Unit-Test","permalink":"https://xjhao.studio/tags/Unit-Test/"},{"name":"golang","slug":"golang","permalink":"https://xjhao.studio/tags/golang/"},{"name":"Cryptocurrency","slug":"Cryptocurrency","permalink":"https://xjhao.studio/tags/Cryptocurrency/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://xjhao.studio/tags/Deep-Learning/"},{"name":"GAN","slug":"GAN","permalink":"https://xjhao.studio/tags/GAN/"},{"name":"Python","slug":"Python","permalink":"https://xjhao.studio/tags/Python/"},{"name":"Tools","slug":"Tools","permalink":"https://xjhao.studio/tags/Tools/"},{"name":"Web Development","slug":"Web-Development","permalink":"https://xjhao.studio/tags/Web-Development/"}]}