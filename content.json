{"meta":{"title":"XJ Studio","subtitle":"It's Xingjian Hao's Personal Blog","description":"","author":"Xingjian Hao","url":"https://xjhao.studio","root":"/"},"pages":[{"title":"Archives","date":"2021-12-06T05:10:01.000Z","updated":"2021-12-06T04:10:00.000Z","comments":true,"path":"archives/index.html","permalink":"https://xjhao.studio/archives/index.html","excerpt":"","text":""},{"title":"About Me","date":"2021-12-06T05:08:18.000Z","updated":"2023-02-27T22:22:59.594Z","comments":true,"path":"about/index.html","permalink":"https://xjhao.studio/about/index.html","excerpt":"","text":"Hi, this is Xingjian…Who am IGraduate Student at Brown University. Born and raised in Jinan, China. Amateur guitarist, photographer, rock enthusiastic and more. What can I doSome skill stacks I have… Programming Language (C++, Python, Go, Java) Web Development (css, JavaScript, React, Node JS) Distributed System (k8s, ceph, rook, MapReduce, Hadook) Cloud Service (AWS EC2, AWS S3) ML&#x2F;DL (Tensorflow, Pytorch, SciKit) About this WebsiteThis website is build on Hexo with theme Aomori. Comment system based on Gitalk, and site-wise seraching based on Algolia. Some of the cover pictures are collected from Pexels, a copyright free photography website."},{"title":"category","date":"2020-06-26T05:10:36.000Z","updated":"2022-03-22T20:06:08.000Z","comments":true,"path":"categories/index.html","permalink":"https://xjhao.studio/categories/index.html","excerpt":"","text":""},{"title":"Friends","date":"2020-06-26T05:11:00.000Z","updated":"2023-02-27T04:31:13.189Z","comments":true,"path":"friends/index.html","permalink":"https://xjhao.studio/friends/index.html","excerpt":"","text":""},{"title":"Reading List","date":"2022-09-07T14:10:22.000Z","updated":"2022-09-08T19:52:14.000Z","comments":true,"path":"collections/index.html","permalink":"https://xjhao.studio/collections/index.html","excerpt":"","text":"What’s this Page?This is a place I use to store all useful resources and articles. They are certified by myself to be helpful and worth-reading. AlgorithmsLabuladong Leetcode Highly detailed leetcode explaination and guide note book. All topics covers around 150 algroithm questions."},{"title":"Search","date":"2023-02-26T02:55:44.884Z","updated":"2022-03-22T16:26:40.000Z","comments":true,"path":"search/index.html","permalink":"https://xjhao.studio/search/index.html","excerpt":"","text":""},{"title":"'tag'","date":"2020-06-26T05:10:44.000Z","updated":"2022-09-07T04:31:54.000Z","comments":true,"path":"tag/index.html","permalink":"https://xjhao.studio/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"Modist - a Safer Partitioning Option","slug":"modist","date":"2023-02-26T03:36:36.000Z","updated":"2023-02-27T21:47:13.508Z","comments":true,"path":"02/25/2023/modist/","link":"","permalink":"https://xjhao.studio/02/25/2023/modist/","excerpt":"Partitioning is necessary when the size of data exceeds the capacity of a single machine. By distributing the workload on each node, the performance is expected to boost by the coefficient manner. In this project, Modist, I explored the structure and functionalities of a distributed system with sharding&#x2F; partitioning capability, and received some inspiration from the unit test process.","text":"Partitioning is necessary when the size of data exceeds the capacity of a single machine. By distributing the workload on each node, the performance is expected to boost by the coefficient manner. In this project, Modist, I explored the structure and functionalities of a distributed system with sharding&#x2F; partitioning capability, and received some inspiration from the unit test process. Implementation * Due to ethical consideration, this repo will remain private util the end of Spring 2023 semesterModist is a client-server structured system that manage multiple functionalities and interactions between nodes with multiple server process. The client node communicate with routers to get information for future TCP connections and interact with partitioners to locate and replicate the key information. The cluster of all server side nodes is called Orchestrator, which configure each node and build up gRPC connections between them. The connection between nodes are passed through protocol buffers. Protocol buffers are a data format to transfer binary representations of objects across the network, which lead to a higher throughput. Within each buffer, a message is passed to node. Protobuf messages are aggregates containing a set of typed fields: resolveableKV, message key with vector clock tas, required syntactic sugar used by Protobuf to order these fields in the binary format of the message Standard data types (bool, int, etc.) are available as well as keywords like optional and repeated Clock and ConflictsModist take both physical and vector clock as its synchronize tool. Within each node, a resolver is implemented to handle the conflict when to incoming events holds different vector clocks. By definition, the highest clock value on each node will be kept as the latest time marker. The vector clock also handles new event by define empty value as zero, and assign them as concurrent. Modist using these mechanisms to acquire the happen-before relationship between events, and eventually keep a causal consistency. Leaderless ReplicationLeaderless replication is a safety guarantee when one node holding data is done. In Modist, a leaderless replication is applied when a request is made. The process of writing or reading from the replication is called a Quorum. While the client contact the Orchestrator, it use matrices R and W to indicate the number of replication that will participate the operation. Normally, for a given n node system, having W + R &gt; n can guarantee that the replicated key can be read when needed. To reach eventual consistency among nodes, read repair is required. By repair we mean to update the out-dated value on a node to the latest if detected. Therefore, the deterministic will be the vector clock. Coordinator detects stale values on other nodes and locally when it issues a read request, can then correct these values with the most up-to-date value. Unit TestUnit tests are conducted along with the development process of each feature. The goal is to cover the codes as much as possible so all features and operations can be tested without any bug. While composing the testing files, some special cases inspired me and my future unit testing and program designing. Adoptability of nil valueNil value can be tricky when it comes to adoptability. In some cases you just need to treat them as zero, while in other cases its an issue you need to take care of. When it comes to value comparison, recognize them as zero can be a feasible approach. You just need to add some mechanism that assign empty value to zero when read them, and it will be all set for comparison. However, when it becomes to the collecting keys, the nil situation should be treat specially. For example, in Modist, when you trying to read a key from a node that didn’t receive a replication, you can make up a fake clock and return value to indicate the missing value. Fake clock can be acquired by the request clocks, therefore you won’t be worry about mistaken conflicts. Moreover, you need a ignorance mechanism when a nil is detected. Some data structures naturally handles these situations, or you can add additional statement to process only when it return message has a value in it. To be continued…","categories":[{"name":"Programming","slug":"Programming","permalink":"https://xjhao.studio/categories/Programming/"}],"tags":[{"name":"Distributed System","slug":"Distributed-System","permalink":"https://xjhao.studio/tags/Distributed-System/"},{"name":"golang","slug":"golang","permalink":"https://xjhao.studio/tags/golang/"},{"name":"gRPC","slug":"gRPC","permalink":"https://xjhao.studio/tags/gRPC/"},{"name":"Unit Test","slug":"Unit-Test","permalink":"https://xjhao.studio/tags/Unit-Test/"}]},{"title":"liteminer","slug":"liteminer","date":"2023-02-07T21:04:00.000Z","updated":"2023-02-27T22:06:54.301Z","comments":true,"path":"02/07/2023/liteminer/","link":"","permalink":"https://xjhao.studio/02/07/2023/liteminer/","excerpt":"Many cryptocurrencies use a distributed consensus protocol to ensure security and authority. In this project I implemented a peer-to-peer networking and proof of work mechanism. In the case of cryptocurrencies, nodes are miners which may drop in and out of the network for various reasons: a miner may crash (or reboot), or a new miner may be added. These changes to the network happen in an unscheduled and unpredictable manner and special care must therefore be taken to ensure that no information is lost.","text":"Many cryptocurrencies use a distributed consensus protocol to ensure security and authority. In this project I implemented a peer-to-peer networking and proof of work mechanism. In the case of cryptocurrencies, nodes are miners which may drop in and out of the network for various reasons: a miner may crash (or reboot), or a new miner may be added. These changes to the network happen in an unscheduled and unpredictable manner and special care must therefore be taken to ensure that no information is lost. Implementation * Due to ethical consideration, this repo will remain private util the end of Spring 2023 semesterMotivated by the hash function within boundaries. By distributing the calculation workload, the eventual proof-of-work is ensured by the key value with largest hash. Since the system required multi-threading and parallel computing, we used Atomic and mutex locks to prevent race condition. Atomic vars are used to protect simple types such as bool, int, string, while mutexes are used to protect maps, slices, and customized structs. Proof of WorkIn cryptocurrencies like Bitcoin, blocks which contain a collection of transactions are constantly created and validated by network participants that perform a computationally intensive task. This is often referred to as proof of work. A common proof of work scheme involves finding a number referred to as a nonce that when concatenated to a string and hashed results in a new string that has a certain property. In Bitcoin, the proof of work entails finding the nonce that, when concatenated with the transaction data and hashed, results in a string that starts with a series of zeros. The fundamental insight is that doing the work to find such a nonce is computationally expensive and requires a lot of resources; therefore, in order to “cheat” the system, one needs to have more resources than all other participants combined. MinerIn a cryptocurrency network, we refer to a miner as a worker that attempts to verify transactions by performing proof of work. Given a financial transaction encoded as a string M and an unsigned integer N, a miner will need to find the nonce between 0 and N, inclusive, that, when concatenated with M and hashed, results in the lowest hash value. PoolA pool is a collection of multiple miners and is responsible for distributing the work amongst its miners. It will also handle top-level logic and communications for a client. In this assignment, you will develop a pool and its corresponding miners with the following properties: The pool must take client requests and shard these requests (distribute the work) across all of its miners. The pool must keep track of the miners under its control and allow miners to come and go at will. The pool must aggregate miner responses and return the proof of work to the client. In a centralized system, this process can take a considerable amount of time. In a distributed system, you will be able to divide up the work, but you must take care when dealing with faulty miners (i.e., miners that drop in and out). Our pool takes a channel to marking the waiting mining tasks and to prevent the conflict of concurrent accessing by its FIFO characteristic. When a node is lost, the task will be return to the queue and wait for a new miner to grab. Only when all tasks in the channel are taken and all nonces are collect will the pool return a final proof-of-work. The miner will remain alive and waiting for the next mining task from the pool.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://xjhao.studio/categories/Programming/"}],"tags":[{"name":"Distributed System","slug":"Distributed-System","permalink":"https://xjhao.studio/tags/Distributed-System/"},{"name":"Cryptocurrency","slug":"Cryptocurrency","permalink":"https://xjhao.studio/tags/Cryptocurrency/"},{"name":"golang","slug":"golang","permalink":"https://xjhao.studio/tags/golang/"}]},{"title":"autoMIDI","slug":"autoMIDI","date":"2022-12-13T14:12:35.000Z","updated":"2023-02-27T22:43:45.263Z","comments":true,"path":"12/13/2022/autoMIDI/","link":"","permalink":"https://xjhao.studio/12/13/2022/autoMIDI/","excerpt":"","text":"","categories":[{"name":"Programming","slug":"Programming","permalink":"https://xjhao.studio/categories/Programming/"}],"tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://xjhao.studio/tags/Deep-Learning/"},{"name":"GAN","slug":"GAN","permalink":"https://xjhao.studio/tags/GAN/"},{"name":"Python","slug":"Python","permalink":"https://xjhao.studio/tags/Python/"}]},{"title":"Correct Method to Deploy your Hexo Website onto Github Pages","slug":"Correct_Method_to_Deploy_your_Hexo_Website_onto_Github_Pages","date":"2020-07-05T04:51:06.000Z","updated":"2023-02-27T21:01:07.613Z","comments":true,"path":"07/05/2020/Correct_Method_to_Deploy_your_Hexo_Website_onto_Github_Pages/","link":"","permalink":"https://xjhao.studio/07/05/2020/Correct_Method_to_Deploy_your_Hexo_Website_onto_Github_Pages/","excerpt":"After weeks of massing around with web platforms, I finally figured out the correct method to deploy my Hexo website onto Github Pages. It’s not hard and not complicated.","text":"After weeks of massing around with web platforms, I finally figured out the correct method to deploy my Hexo website onto Github Pages. It’s not hard and not complicated. Prerequisites: you website, your github repo, a solid internet connection The hexo document website has a detailed instruction about what you should prepare, so I’ll leave the job to them. After your website is finished with all impelmentations you want, run the following command: $ npm install hexo-deployer-git -save This plugin would generate the correct form for your deploy to Github Page. Then open _config.yml of your website and make the following edit: # URL url: https:&#x2F;&#x2F;username.github.io&#x2F; # Deployment deploy: type: git repo: https:&#x2F;&#x2F;github.com&#x2F;&lt;username&gt;&#x2F;&lt;reponame&gt;.git branch: master This would set up the link to your repo, so you don’t have to wake up Git(which makes a lot trouble if you use SSH connection on Windows). Then you are one step before deployment. Simply run: $ hexo clean $ hexo generate $ hexo deploy to generate the correct website and push them into your repo. Then your website should be available on https://username.github.io/.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://xjhao.studio/categories/Programming/"}],"tags":[{"name":"Web Development","slug":"Web-Development","permalink":"https://xjhao.studio/tags/Web-Development/"}]}],"categories":[{"name":"Programming","slug":"Programming","permalink":"https://xjhao.studio/categories/Programming/"}],"tags":[{"name":"Distributed System","slug":"Distributed-System","permalink":"https://xjhao.studio/tags/Distributed-System/"},{"name":"golang","slug":"golang","permalink":"https://xjhao.studio/tags/golang/"},{"name":"gRPC","slug":"gRPC","permalink":"https://xjhao.studio/tags/gRPC/"},{"name":"Unit Test","slug":"Unit-Test","permalink":"https://xjhao.studio/tags/Unit-Test/"},{"name":"Cryptocurrency","slug":"Cryptocurrency","permalink":"https://xjhao.studio/tags/Cryptocurrency/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://xjhao.studio/tags/Deep-Learning/"},{"name":"GAN","slug":"GAN","permalink":"https://xjhao.studio/tags/GAN/"},{"name":"Python","slug":"Python","permalink":"https://xjhao.studio/tags/Python/"},{"name":"Web Development","slug":"Web-Development","permalink":"https://xjhao.studio/tags/Web-Development/"}]}